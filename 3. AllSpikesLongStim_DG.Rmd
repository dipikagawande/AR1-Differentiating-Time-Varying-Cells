---
header-includes:
   - \usepackage{soul}
   - \usepackage{color}
   - \usepackage{fancyhdr}
   - \usepackage{lipsum}
title: " **Results** | 7a: All spikes, long stimulation data"
author: "Dipika Gawande"
date: "14 December 2022"
output: pdf_document
fontsize: 10pt
toc: true
bibliography: References.bib
number_sections: true
knit: (function(inputFile, encoding) { 
  rmarkdown::render(inputFile,
  encoding=encoding, 
  output_file=file.path('iv. PDF Knits', '3. AllSpikesLongStim_DG')) 
  })
---

\sffamily
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\rightmark}
\lfoot{Results | 7a: All Spikes, Long Stimulation}


```{r setup, message=FALSE, include=FALSE}
# rm(list=ls())
## Options
library(knitr)
options(digits.secs=5)

## Import packages
library(readxl)
library(tidyverse)
library(dplyr)
# Plots in ggplot
library(ggplot2)
# To create lag vars in time series
library(Hmisc)
# For unit root test
library(urca)
# For robust standard errors in OLS regression
library(estimatr)
# For regression tables
library(stargazer)
# For cross-validation and test error
library(caret)
# For tables
library(kableExtra)

## Set color vector for all graphs
colors <- c("goldenrod", "firebrick", "gray20")
```

```{r Data Loading, include=FALSE}

## Read in the cleaned data frame with key vars generated by Appendix
df_short <- read.csv("ii. Working Data/AllSpikes_LongStim_df_short.csv")
## Our 4 key vars
the_vars <- c("log_Imax", "log_t12", "log_Q", "Wait_time")
## Create df_unique
df_unique <- df_short %>%
    group_by(CellID, Cell.Type) %>%
    summarise(n = n()) %>%
    arrange(Cell.Type, CellID)
```

# 7a. Results: All spikes, long stimulation

## 1) Data Summary

These results are based on the raw file `MT220412_AllSpk_WT_K189_K326.xlsx`, 
which contains **All spikes, long stimulation** data. The file contains all the 
spikes detected by the program, including overlapping spikes, adjusted for 
baseline by Dr. Karatekin's lab. The stimulation period for each cell under 
this experimental condition is 30 seconds. The spikes generated by the cell are 
recorded for an additional 60 seconds. There are 59 unique cells in this data 
set.

```{r Table of original cells by var, echo=FALSE}

## Check that original data has variable values for all spikes
# colSums(is.na(df_short))
## Summarize number of cells and spikes in original data
df_short_summ <- df_short %>%
  group_by(Cell.Type) %>%
  summarise(tot_spikes = as.numeric(n()),
            tot_cells = as.numeric(n_distinct(CellID))) %>%
  rename(Group = Cell.Type)

knitr::kable(df_short_summ %>%
        rename("Total Cells" = tot_cells,
               "Total Spikes" = tot_spikes),
      caption = "Total cells in the data set", 
      'pandoc')

```

## 2) Fixed-effects ANOVA

Before we test for the dependency of within-cell observations in the next 
section, we test if an ANOVA of fixed-effects shows significant difference 
between WT and treatment cell-level means of any of our 4 key variables. 
Essentially assuming that all within-cell observations are dependent, we are 
testing for a between-group difference in cell fixed-effects.

```{r Fixed Effects ANOVA, comment=NA, warning=FALSE, include=FALSE, echo=FALSE}

## Do ANOVA using row IDs for just two groups at a time. Since we are using mean
## vars at the level of the cell, we have only 40-1 degrees of freedom for each 
## test (21 WT cell mean values and 19 mutant cell mean values).

## Make df of cell-level means
df_ftest <- df_short %>%
  group_by(CellID, Cell.Type) %>%
  summarise(n = n(), across(all_of(the_vars), mean))

## Write a function that maps through the cell-level mean vars and carries
## out an ANOVA of cell fixed-effects
aov_fe_func <- function(row_idx) {
  df_ftest[row_idx, the_vars] %>%
    map(~ summary(aov(. ~ df_ftest$Cell.Type[row_idx])))
}

## Write a function that appends results of ANOVA by var into a data frame
aov_append_func <- function(a) {
  ## Initialize results dataframe
  df_anova <- data.frame(matrix(ncol = 4, nrow = 0))
  for (i in 1:length(a)) {
    ## Decide rejection of null
    result <- "Cannot Reject H0"
    if (a[[i]][[1]]$`Pr(>F)`[1] <= 0.05) result <- "H0 Rejected"
    ## Compile row
    this_row <- c(names(a[i]), 
           round(a[[i]][[1]]$`F value`[1], 3), 
           round(a[[i]][[1]]$`Pr(>F)`[1], 3), 
           result)
    ## Append row
    df_anova <- rbind(df_anova, this_row)
  }
  colnames(df_anova) <- c("Variable", "F-statistic", "p-value", "Result")
  df_anova
}
```


```{r output ANOVA K189, echo = FALSE}

## Fixed-effects ANOVA for WT versus K189. Assume equal variances for
## easier interpretability
WT_and_K189 <- which(df_ftest$Cell.Type %in% c("WT", "K189"))
results <- aov_fe_func(WT_and_K189)
table <- aov_append_func(results)
knitr::kable(table, 
      caption = "Results for fixed-effect ANOVA of WT vs K189 (df = 39)",
      'pandoc')
```


```{r output ANOVA K326, echo = FALSE}
## Fixed-effects ANOVA for WT versus K326. Assume equal variances for 
## easier interpretability
WT_and_K326 <- which(df_ftest$Cell.Type %in% c("WT", "K326"))
results <- aov_fe_func(WT_and_K326)
table <- aov_append_func(results)
knitr::kable(table,
             caption = "Results for fixed-effect ANOVA of WT vs K326 (df = 39)", 
             'pandoc')
```

We are able to reject equality of means of cell fixed-effect for `log_t12`
and `log_Q` between WT and K189 cells at the 1% significance level. The test 
rejects equality of means of cell fixed-effect for `log_t12` between WT and K326 
cells at the 5% significance level. For all other variables, we are unable
to reject equality of means of cell fixed-effects between WT and either 
treatment. 

As described in Sections 3, 5 and 6 of the main report, we now undertake to 
remove non-stationarity from the data and estimate $\widetilde{y_t}$ versions 
of these variables which are independent from one spike to the next for a given 
cell. 

## 3) Stationary cells for each variable

```{r UR unit root test, echo = FALSE}

## Make empty list to store output UR dataframes for each var
ur_output_dfs <- sapply(the_vars[-1], function(x) NULL)
ur_summary_dfs <- sapply(the_vars[-1], function(x) NULL)

## Run a loop to do the unit root test with trend and drift, and print a 
## UR test statistic table for 4 of the key vars excluding Max_s
for (var in the_vars) {
  
  ## Initialize empty matrix for this variable
  ur_df <- data.frame("Cell_ID" = character(nrow(df_unique)),
                      "Group" = character(nrow(df_unique)),
                      "Num_spikes" = numeric(nrow(df_unique)),
                      "UR_test_stat" = numeric(nrow(df_unique)),
                      "Sig_level" = character(nrow(df_unique)))
  
  for(i in 1:nrow(df_unique)) {
    ## Store this Cell's ID
    this_CellID <- df_unique$CellID[i]
    ## Populate columns 1 and 2 with Cell ID and number of measurements
    ur_df[i, 1] <- this_CellID
    ur_df[i, 2] <- df_unique$Cell.Type[i]
    ur_df[i, 3] <- df_unique$n[i]
    
    ## Unit root test needs >6 measurements to calculate the test statistic
    if (df_unique$n[i] <= 6 ) {
      ## Populate columns 3-6 with NA if cell has <= 6 spikes
      ur_df[i, 4:5] <- NA
    }
    else {
      ## Select rows for this Cell ID
      this_df <- df_short %>% filter(CellID == this_CellID)
      ## Do the unit root test
      ur_out <- ur.df(y = this_df[[var]], type = "trend", lags = 1)
      ## Populate column 3 with the UR test statistic. Extract the first
      ## of the three test statistics because our H0 is tau3.
      stat <- ur_out@teststat[1]
      ur_df[i, 4] <- round(stat, 2)
      ## Populate column 4 with significance level of the UR test statistic
      cvals <- ur_out@cval[1, ]
      ## Loop through critical values to check significance
      if (stat < cvals[1]) {
        ur_df[i, 5] <- "Sig at 0.10"
      } else {
        if (stat < cvals[2]) {
          ur_df[i, 5] <- "Sig at 0.05"
        } else {
          if (stat < cvals[3]) {
            ur_df[i, 5] <- "Sig at 0.01"
          } else {
            ur_df[i, 5] <- "Cannot reject H0"
          }
        }
      }
    }
  }

  ur_summary_table <- ur_df %>%
  filter(Sig_level != "Cannot reject H0") %>%
  group_by(Group) %>%
  summarise(num_cells = n(),
            num_spikes = sum(Num_spikes))
  
  ## Store the unit root table for this var in the output list
  ur_output_dfs[[var]] <- ur_df
  ur_summary_dfs[[var]] <- ur_summary_table
}
```


```{r Table of stationary cells, echo = FALSE}

df_show_summary <- data.frame(matrix(ncol = 6, nrow = 0))

for (i in 1:length(ur_summary_dfs)){
  interim_df <- cbind(rep(names(ur_summary_dfs)[i],3), 
                      ur_summary_dfs[[i]])
  df_show_summary <- rbind(df_show_summary, interim_df)
}

df_stationary_summ  <- df_show_summary %>% 
  left_join(df_short_summ, by = "Group") %>%
  mutate(num_cells = as.numeric(num_cells),
         pct_cells = round((num_cells/tot_cells), 3) * 100,
         pct_spikes = round((num_spikes/tot_spikes), 3) * 100) %>%
  select(-c(tot_spikes, tot_cells)) %>%
  rename(Variable = "rep(names(ur_summary_dfs)[i], 3)",
         "Count Spikes" = num_spikes,
         "Count Cells" = num_cells,
         "% of Total Spikes" = pct_spikes,
         "% of Total Cells" = pct_cells)

knitr::kable(df_stationary_summ, 
             caption = "Stationary cells in the data set by variable", 
             'pandoc')

## Show average of each column in Stationary Summary
table <- t(round(colMeans(df_stationary_summ[, -c(1:2)]), 2))
knitr::kable(table, 
             caption = "Average cell and spike statistics of stationary cells", 
             'pandoc')

```

We see from the above table that on average, 85% of the total data (spikes) in 
the **All spikes, short stimulation** set are stationary. On average, they are 
produced by 55% of the cells (about 10 stationary cells for each of the key 
variables for each cell type). The intersection of cells which are stationary 
for all variables is reported in Subsection 7 of these results. All following 
analysis is conducted using $\widetilde{y_t}$ variables on the subset of cells 
for whom these variables are stationary. *See Appendix for cell-wise results of*
*unit root test for non-stationarity.*

## 4) T-test results on $\widetilde{y_t}$ by variable

This section presents results of t-tests on $\widetilde{y_t}$ for 
stationary cells. For each of the variables, two t-tests are performed:
(1) difference-of-means between WT and K189 stationary cells, and 
(2) difference-of-means between WT and K326 stationary cells. 

```{r lag-1 reg function, echo = FALSE}

## Write a function that fits the lag-1 regression for each var and
## estimates u_t by the residuals
lag1_reg_func <- function(var) {
  
  ## Save data frame of UR statistics for each cell for this variable
  ur_df_this_var <- ur_output_dfs[[var]] 
  
  ## Print number of cells with stationary series for this var
  cat("  \n") 
  print(paste("SUMMARY OF CELLS WITH STATIONARY", var))
    
  stationary_table <- ur_df_this_var %>%
    filter(Sig_level != "Cannot reject H0") %>%
    group_by(Group) %>%
    summarise(num_cells = n(), num_spikes = sum(Num_spikes))
  print(stationary_table)
  
  groups <- c("K189", "K326", "WT")
  st_df_list <- setNames(replicate(3, list()), groups)
  ## For each of the three groups K189, K326 and WT: fit the lag-1 regression
  ## for this var on each group separately, and estimate u_t with the residuals 
  ## of this regression
  for (group in groups) {
  
    ## Print a label
    cat("  \n") 
    print(paste("LAG-1 REGRESSION OF", var, "FOR GROUP", group))
    
    ## Get Cell IDs of cells in this group with stationary series for this var
    st_CellIDs_thisgroup <- 
      ur_df_this_var$Cell_ID[ur_df_this_var$Group == group 
                             & ur_df_this_var$Sig_level %in% c("Sig at 0.01", 
                                                               "Sig at 0.05", 
                                                               "Sig at 0.10")]
    ## Print a label
    print(paste(length(st_CellIDs_thisgroup), group, 
                "CELLS HAVE STATIONARY", var))
    
    ## Subset of df_short with the stationary cells for this var in this group 
    this_subset_df <- df_short %>%
      group_by(CellID) %>%
      arrange(CellID, Max_s) %>%
      ## Create lag-1 version of this variable
      mutate(l1_var = Lag(eval(parse(text = var)), + 1)) %>%
      filter(CellID %in% st_CellIDs_thisgroup)
    
    ## Fit the lag-1 regression for the stationary Wait_time cells in this group
    this_reg <- 
      lm(eval(parse(text = var)) ~ l1_var*factor(CellID) + Max_s*factor(CellID), 
         data = this_subset_df, 
         na.action = na.exclude)
    ## Print the regression
    print(summary(this_reg))
    
    ## Add residuals and y_hat to the stationary subset data frame for this group
    this_subset_df <- cbind(this_subset_df, 
                            resid = resid(this_reg), 
                            fitted = fitted(this_reg)) %>%
      group_by(CellID) %>%
      ## Check that the sum of residuals for each cell is ~zero
      mutate(sum_resid = sum(resid, na.rm = TRUE))
    
    ## Show that the residuals (u_t hat) have lower variance than y_t
    print(paste("VARIANCE OF", var, "(y_t) FOR", group, "=",
                round(var(this_subset_df[, var]), 3)))
    print(paste("VARIANCE OF RESIDUALS (u_t) FOR", group, "=",
                round(var(this_subset_df$resid, na.rm = TRUE), 3)))
    cat("  \n")
    cat("  \n")
    
    ## Save the stationary Wait_time subset data frame for this group
    st_df_list[[group]] <- this_subset_df
  }
  assign("st_df_list", st_df_list, envir = .GlobalEnv)
}
```


```{r t-tests for ytilde vars, include = FALSE}

ttest_df_K189 <- data.frame(matrix(ncol = 4, nrow = 0))
ttest_df_K326 <- data.frame(matrix(ncol = 4, nrow = 0))

for (var in the_vars) {
  ## Lag-1 regression on this var
  lag1_reg_func(var)
  ## Estimate u_t and ytilde for this var
  df_st_thisvar <- rbind(st_df_list$K189, st_df_list$K326, st_df_list$WT) %>%
    select(CellID, Cell.Type, nspikes, Max_s, as.name(var), resid) %>%
    group_by(CellID) %>%
    mutate(mean_thisvar = mean(eval(parse(text = var))),
         y_tilde = resid + mean_thisvar)
  ## Save this var's data frame of stationary cells for use in later code
  assign(paste0("df_st_", var), df_st_thisvar, envir = .GlobalEnv)
  
  ## Get Cell IDs for (1) WT versus K189 and (2) WT versus K326
  ## for only the cells that are stationary for this var
  WT_and_K189 <- which(df_st_thisvar$Cell.Type %in% c("WT", "K189"))
  WT_and_K326 <- which(df_st_thisvar$Cell.Type %in% c("WT", "K326"))
  ## T-test on y_tilde
  K189_t <- t.test(y_tilde[WT_and_K189] ~ Cell.Type[WT_and_K189], 
                 data = df_st_thisvar)
  K326_t <- t.test(y_tilde[WT_and_K326] ~ Cell.Type[WT_and_K326], 
                 data = df_st_thisvar)
  
  ## Save results for table -- WT vs K189
  result_K189 <- "Cannot Reject H0"
  if (K189_t$p.value <= 0.05) result_K189 <- "H0 Rejected"
  ## Append this var's row to the K189 t-test result df
  ttest_df_K189  <- rbind(ttest_df_K189,
                          c(paste0("ytilde_", var), 
                            round(K189_t$statistic, 3), 
                            round(K189_t$p.value, 3), 
                            result_K189))

  ## Save results for table -- WT vs K189
  result_K326 <- "Cannot Reject H0"
  if (K326_t$p.value <= 0.05) result_K326 <- "H0 Rejected"
  ## Append this var's row to the K326 t-test result df
  ttest_df_K326 <- rbind(ttest_df_K326,
                         c(paste0("ytilde_", var), 
                           round(K326_t$statistic, 3), 
                           round(K326_t$p.value, 3), 
                           result_K326))
}
colnames(ttest_df_K189) <- c("Variable", "t-statistic", "p-value", "Result")
colnames(ttest_df_K326) <- c("Variable", "t-statistic", "p-value", "Result")

```

```{r output t-test table, echo = FALSE}
knitr::kable(ttest_df_K189, 
             caption = "T-test for difference of means of ytilde vars 
             between WT and K189", 'pandoc')

knitr::kable(ttest_df_K326,
             caption = "T-test for difference of means of ytilde vars 
             between WT and K326", 'pandoc')
```

Whereas the initial ANOVA of cell fixed-effects could not reject equality of 
means between WT and either treatment for many of the original variables, after
correcting for non-stationarity in the data we find a significant difference 
in mean $\widetilde{log\_Imax}_{t}$, $\widetilde{log\_t12}_{t}$, and
$\widetilde{log\_Q}_{t}$  between WT and K189 stationary cells at the 1% level. 
We find a statistically significant difference in mean $\widetilde{y_t}$ between 
WT and K326 stationary cells for all four variables at the 1% level. *See 
appendix for full t-test output and our check that mean, variance and 
degrees of freedom are comparable between the original variables $y_t$ and 
their time-independent versions $\widetilde{y_t}$.*

## 5) Estimates of Average Treatment Effects

All following models in Subsection 5 and 6 of these results are performed on 
the intersection of cells in the data which are stationary for all variables in 
the model. In this data, **2075 of 3398 (61%) total spikes (observations) are**
**stationary** across all four of our key variables. These spikes are 
produced by **18 of 59 (31%) total cells**. So, all following models are 
estimated on the stationary 61% intersection of the data from these 18 cells.

```{r Make df_stationary_all, include = FALSE}

## First make data set of just the stationary cells for all variables, and 
## the y_tilde version of the variable. Use inner join to do this, merging
## each variable's stationary data set into our original df_short and keeping
## only the rows that match from both sets. We want the intersection of 
## cells that are stationary for all variables to run our regression.

by_keys <- c("CellID", "Max_s", "Cell.Type", "nspikes")
df_st_all <- df_short %>%
  ## Inner join stationary Wait_time
  inner_join(df_st_Wait_time, by = c(by_keys, "Wait_time")) %>%
  select(-c(resid, mean_thisvar)) %>%
  rename(ytilde_wait = y_tilde) %>%
  ##  Inner join stationary log_t12
  inner_join(df_st_log_t12, by = c(by_keys, "log_t12")) %>%
  select(-c(resid, mean_thisvar)) %>%
  rename(ytilde_logt12 = y_tilde) %>%
  ##  Inner join stationary log_Imax
  inner_join(df_st_log_Imax, by = c(by_keys, "log_Imax")) %>%
  select(-c(resid, mean_thisvar)) %>%
  rename(ytilde_logImax = y_tilde) %>%
  ##  Inner join stationary log_Q
  inner_join(df_st_log_Q, by = c(by_keys, "log_Q")) %>%
  select(-c(resid, mean_thisvar)) %>%
  rename(ytilde_logQ = y_tilde)

## Check how many (stationary across all 4 vars!) cells in each group we have
df_st_all %>%
  group_by(CellID, Cell.Type) %>%
  summarise(n = n()) %>%
  arrange(Cell.Type)

## What fraction of the total data/total spikes is stationary?
nrow(df_st_all) / nrow(df_short) 
## What fraction of the total cells are responsible for the stationary data?
18/59

## Summarize intersection of cells and spikes that are stationary across
## all four variables
df_st_summ <- df_st_all %>%
  group_by(Cell.Type) %>%
  summarise(tot_spikes = as.numeric(n()),
            tot_cells = as.numeric(n_distinct(CellID))) %>%
  rename(Group = Cell.Type)

knitr::kable(df_st_summ %>%
               rename("Total Cells" = tot_cells,
                      "Total Spikes" = tot_spikes),
             caption = "Intersection of cells which are stationary for all
             four key variables", 'pandoc')
```

### 5a) Robustness check for Average Treatment Effect

Tables 8 and 9 present a summary of robustness checks for the estimates
of Average Treatment Effect (ATE) on each $\widetilde{y_t}$ variable for K189
and K326. The baseline (intercept term) in each model is WT. (*See Appendix* 
*for regression output and coefficient estimates.*) Models are performed on the 
intersection of cells in the data which are stationary for all variables 
in the model.

```{r Robustness ATE for K189, echo = FALSE, results='asis'}
r_table_k189 <- data.frame(outcome = as.character(),
                           coef_bounds = as.character(),
                           Robust = as.character(),
                           Observations = as.integer())
r_table_k189[1, ] <- c("ytilde_Wait_time", "[-0.022, -0.005]", "No", 2057)
r_table_k189[2, ] <- c("ytilde_log_t12", "[-0.210***, -0.808***]", "Yes", 2057)
r_table_k189[3, ] <- c("ytilde_log_Imax", "[0.131***, 0.584***]", "Yes", 2057)
r_table_k189[4, ] <- c("ytilde_log_Q", "[-0.687*, 0.461***]", "No", 2057)

## Output the table. So sorry -- line breaks in the footnote cause errors!
kbl(r_table_k189, align = "c",
    col.names = c("Outcome", "Coefficient Bounds", "Robust", "Observations"),
    caption = "Average Treatment Effect (from four different models) on 
    K189 stationary cells",
    format = "latex", booktabs = T, position = "h!") %>%
  kable_styling(font_size = 9) %>%
  footnote("For each outcome, we estimate the treatment effect from four models. This table reports the max and min of these four treatment effects. The four models have have different control variables. The sample consists of observations from the intersection of stationary cells. Statistical significance at is based on robust standard errors. *p<0.1; **p<0.05; ***p<0.01.", threeparttable = T)

```


```{r Robustness ATE for K326, echo = FALSE, results = 'asis'}
r_table_k326 <- data.frame(Outcome = as.character(),
                           'Coefficient Bounds' = as.character(),
                           'Robust' = as.character(),
                           'Observations' = as.integer())
r_table_k326[1, ] <- c("ytilde_Wait_time", "[-0.209***, -0.191***]", "Yes", 2057)
r_table_k326[2, ] <- c("ytilde_log_t12", "[-0.447***, -0.085***]", "Yes", 2057)
r_table_k326[3, ] <- c("ytilde_log_Imax", "[0.161***, 0.613***]", "Yes", 2057)
r_table_k326[4, ] <- c("ytilde_log_Q", "[-0.414*, 0.511***]", "No", 2057)

## Output the table. So sorry -- line breaks in the footnote cause errors!
kbl(r_table_k326, 
    col.names = c("Outcome", "Coefficient Bounds", "Robust", "Observations"),
    caption = "Average Treatment Effect (from four different models) 
    on K326 stationary cells", 
    linesep = "",
    format = "latex", booktabs = T, position = "h!") %>%
  kable_styling(font_size = 9) %>%
  footnote("For each outcome, we estimate the treatment effect from four models. This table reports the max and min of these four treatment effects. The four models have have different control variables. The sample consists of observations from the intersection of stationary cells. Statistical significance at is based on robust standard errors. *p<0.1; **p<0.05; ***p<0.01.", threeparttable = T)
```

We observe that the estimates of Average Treatment Effect (ATE) on all variables
except `log_Q` are robust to different subsets of regressors. The
estimate of ATE on `Wait_time` is statistically significant for K326, 
but not for K189 stationary cells. This supports the results of our t-tests. 
*Appendix 7a), Table 10* reports the regression output of $\widetilde{log\_Q}$ 
on the other variables. It is possible that `Q` (a measure of area under 
the spike) is nearly a mathematical function of `t12` (spike width) and 
`Imax` (spike amplitude/height). This is a caveat to interpreting results
causally.


### 5b) Interaction Effects

The tables in this section present difference-in-differences estimates, that is,
the interaction effects among variables. In formal terms, this is the cross-
partial derivative $\frac{\partial^2 y}{\partial x_1 \partial x_2}$, where:

* $y$ is an outcome, for example $\widetilde{log\_t12}$
* $x1$ is another variable from the experiment, for example 
$\widetilde{log\_Imax}$
* $x2$ is the treatment indicator `Cell.Type`

The difference-in-differences between WT and K326 in Figure 1 (*Appendix 7a,
Table 12 reproduced as a figure below*), Model 2 is interpreted as the 
difference between:

(1) the change in $\widetilde{log\_t12}$ associated with a one-unit change in 
$\widetilde{log\_Imax}$ (that is, the percentage change in `t12` 
due to a 100% change in `Imax`) for WT cells, and

(2) the change in $\widetilde{log\_t12}$ associated with a one-unit change in 
$\widetilde{log\_Imax}$ for K326 cells.

```{r diff-in-diff_logt12.png, echo = FALSE, fig.cap = "Difference-in-differences: $\\widetilde{log\\_t12_t}$", fig.align = "center", out.width = '65%'}
knitr::include_graphics("iii. Images/diff-in-diff_logt12.png")
```

All three difference-in-differences (DiD) in Appendix Table 12 are 
statistically significant for K326 stationary cells at the 1% level. For 
example, the change in `t12` associated with a 100% change in 
`Imax` is 23.5% less for K326 cells than for WT cells. The change in 
`t12` associated with a 100% change in `Q` is 14.0% less for K326 cells 
than for WT cells. It appears that the K326 treatment is more robust across all
DiDs than is the K189 treatment.


```{r diff-in-diff_logImax.png, echo = FALSE, fig.cap = "Difference-in-differences: $\\widetilde{log\\_Imax_t}$", fig.align = "center", out.width = '65%'}
knitr::include_graphics("iii. Images/diff-in-diff_logImax.png")
```

```{r diff-in-diff_logQ.png, echo = FALSE, fig.cap = "Difference-in-differences: $\\widetilde{log\\_Q_t}$", fig.align = "center", out.width = '65%'}
knitr::include_graphics("iii. Images/diff-in-diff_logQ.png")
```

What we observe in Figure 1 (*Appendix 7a, Table 12*) above, is borne out in 
Figures 2 and 3 (*Appendix 7a, Tables 13 and 14*) for outcome variables
`Imax` and `Q`, respectively.

\newpage

## 6) Logistic regression for classification

In this section we present the result of fitting a logistic regression
model for classification on the intersection of cells that are stationary
for all four key variables. th the key variables. We build two models. The
first classifies WT vs. K189 stationary cells on the basis of the features, 
The second model classifies WT vs. K326 stationary cells.

```{r Prep class_df for logistic reg, include = FALSE}

class_df <- data.frame(df_st_all[, c("CellID", "Cell.Type",
                                     "ytilde_wait", "ytilde_logt12", 
                                     "ytilde_logImax", "ytilde_logQ", "Max_s")])
## Drop ~ 25 rows with NA values
class_df <- na.omit(class_df)

## Scale the numeric columns
class_df[, -c(1,2)] <- scale(class_df[, -c(1,2)])

## Make separate classification data frames for K189 and K326
class_df_K189 <- class_df[class_df$Cell.Type != "K326", -1]
class_df_K326 <- class_df[class_df$Cell.Type != "K189", -1]

## Re-level the labels to only have 2 factor levels
class_df_K189$Cell.Type <- as.character(class_df_K189$Cell.Type)
class_df_K326$Cell.Type <- as.character(class_df_K326$Cell.Type)
## Relevel not working, doing it manually
class_df_K189$Cell.Type <- as.factor(class_df_K189$Cell.Type)
levels(class_df_K189$Cell.Type)
class_df_K326$Cell.Type <- as.factor(class_df_K326$Cell.Type)
levels(class_df_K326$Cell.Type)

## We will want the LOOCV estimate of test error
train_ctrl <- trainControl(method = "LOOCV")

```

### 6a) Statistically significant features

```{r Logistic reg table, echo = FALSE, results = 'asis'}
## Fit and evaluate the logistic reg model for K189 vs WT
set.seed(625)
glm_K189_noCV <- glm(Cell.Type ~ ., 
                     data = class_df_K189, 
                     family = "binomial")
glm_K189 <- train(Cell.Type ~ ., 
                  data = class_df_K189,
                  trControl = train_ctrl,
                  method = "glm",
                  family = "binomial")
## Prep output to stargazer
glm_K189$finalModel$call <- glm_K189_noCV$call

## Fit and evaluate the logistic reg model for K326 vs WT
set.seed(625)
glm_K326_noCV <- glm(Cell.Type ~ ., 
                     data = class_df_K326, 
                     family = "binomial")
glm_K326 <- train(Cell.Type ~ ., 
                  data = class_df_K326,
                  trControl = train_ctrl,
                  method = "glm",
                  family = "binomial")
## Prep output to stargazer
glm_K326$finalModel$call <- glm_K326_noCV$call

## Output regression table to stargazer
stargazer(glm_K189$finalModel, glm_K326$finalModel,
          type = "latex", font.size = "footnotesize", header = FALSE,
          dep.var.labels = "Cell Type",
          column.labels = c("WT vs. K189", 
                             "WT vs. K326"),
          covariate.labels = c("$\\widetilde{Wait\\_time_t}$",
                               "$\\widetilde{log\\_t12_t}$",
                               "$\\widetilde{log\\_Imax_t}$",
                               "$\\widetilde{log\\_Q_t}$",
                               "$Max\\_s_t$",
                               "Constant"),
          title = "Coefficient estimates of logistic regression model
          for classification",
          notes = c("Regressions are performed on the intersection of cells in", 
                    "the data that are stationary for all variables in the 
                    model."))
```


Table 10 shows that the features $\widetilde{log\_t12}$, 
$\widetilde{log\_Imax}$, and 
$\widetilde{log\_Q}$ are statistically significant for the logistic
regression model classifying between K189 and WT stationary cells in this
data set.

All four variables are statistically significant for the logistic
regression model classifying between K326 and WT stationary cells in this
data set.

### 6b) Prediction accuracy of the models

Tables 10 and 11 present the leave-one-out cross-validation (LOOCV) 
estimates of the models' prediction accuracy on test data. The Kappa
value in each model's table is a measure of classification accuracy that
normalizes for the baseline of correct assignment (called "agreement") 
occurring by random chance in the data set. 

Note: Kappa is a more relevant measure of model classification accuracy for
data sets with an imbalance in the classes. Our intersection of stationary
cells has balanced class values (roughly equal number of observations for
WT, K189 and K326 cell classes). Kappa between 0.4 and 0.6 indicates 
moderate agreement; between 0.6 and 0.8 indicates substantial agreement 
[@landis].

```{r Output logistic reg accuracy table, echo = FALSE}
## Initialize empty results data frame
model_results <- data.frame(matrix(nrow = 2, ncol = 3))
## Save model results for WT vs. K189 in first row
model_results[1, ] <- c("WT vs K189", 
                       round(glm_K189$results[1, "Accuracy"], 3), 
                       round(glm_K189$results[1, "Kappa"], 3))
model_results[2, ] <- c("WT vs K326", 
                       round(glm_K326$results[1,"Accuracy"], 3), 
                       round(glm_K326$results[1,"Kappa"], 3))
  
colnames(model_results) <- c("Model", "Accuracy", "Kappa")

kable(model_results,
caption = "Test accuracy of logistic regression model
            on WT vs. Treatment", 'pandoc') 
```

Table 11 shows that the logistic regression model for WT vs. K189 classifies 
cell type for stationary cells in this data set with 72% test accuracy, 
given the four $\widetilde{y_t}$ features and `Max_s`. The logistic regression 
model for WT vs. K326 classifies cell type for stationary cells in this data 
set with 71% test accuracy, given the four features features and `Max_s`.

From the test accuracy and coefficient estimates of the logistic regression
models, we can see that the variables provide important information about the 
fundamental difference between WT and treatment stationary cells in this 
data set.


------------------
